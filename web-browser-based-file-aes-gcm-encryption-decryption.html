<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<title>Web Browser Based AES-GCM File Encryption/Decryption</title>

		<meta name="description" content="self contained in browser file encryption using the AES-GCM algorithm.">
 		<meta name="author" content="Florian Rienhardt">
		<meta name="generator" content="Notepad++">

		<style>
			html {
				width: 100%;
				height: 100%;
				-webkit-font-smoothing: antialiased;
				margin: 0;
				padding: 0;
				background-color: #fefefe;
				color: #333333;
			}
			body {
				margin: 0 auto;
				padding: 0;
				font-family: "Open Sans", "Helvetica Neue", "Arial", "Verdana", "sans-serif";
				line-height: 1.8;
				font-size: 1.1em;
				font-weight: normal;
			}
			a, a:link, a:visited, a:active  {
				text-decoration: none;
				transition: color .1s linear;
				color: #005190;
				word-wrap: break-word;
			}
			a::after {
				content: "↗️";
			}
			a:hover {
				cursor: pointer;
				color: red;
			}
			a:hover {
				text-decoration: underline;
			}
			.wrapper {
				display: block;
				clear: both;
				box-sizing: border-box;
				padding-left: 0.8em;
				padding-right: 0.8em;
				margin: 0 auto;
				max-width: 1300px;
				min-width: 300px;
			}			
			p, td, span {
				text-align: inherit;
				vertical-align: top;
				white-space: pre-wrap;
				word-wrap: normal;
			}
			pre {
				display: block;
				margin: 0 0 1em;
				background-color: #fefefe;
				border: 1px solid #ccc;
				border-radius: 5px;
			}
			button, input, select, textarea {
				font-size: 1.1em;
				display: inline-block;
				box-sizing: border-box;
				padding: 5px;
				background-color: #fff;
				border: 1px solid #ccc;
				border-radius: 5px;
			}
			.clickbutton {
				display: inline-block;
				clear: both;
				box-sizing: border-box;
				vertical-align: middle;
				cursor: pointer;
				text-transform: none;
				overflow: visible;
				background-color: #337ab7;
				max-width: 450px;
				min-width: 200px;
				border: none;
				border-radius: 5px;
				color: #fff;
				text-align: center!important;
				cursor: pointer;
				padding: 1em;
				margin-top: 0.1em;
				margin-left: 0.1em;
				margin-right: 0.1em;
				margin-bottom: 1em;
			}
			.clickbutton:hover {
				color: #ffffff;
				filter: brightness(80%);
			}
			.green.clickbutton {
				color: #fff;
				background-color: #5cb85c;
			}
			.orange.clickbutton {
				color: #fff;
				background-color: #ff9a00;
			}
			.hidden {
				display: none;
			}
			
			table, td, tr {
				border: 0;
			}
			td {
				padding: 0.5em;
			}
			.redspan::before {
				color: red;
				content: "✖";
				padding-right: 0.3em;
			}
			.greenspan::before {
				color: green;
				content: "✔";
				padding-right: 0.3em;
			}
		</style>

	</head>
<body>

<div class="wrapper">

<h1>Web Browser Based AES-GCM File Encryption/Decryption</h1>
<p>Use your Web Browser to encrypt or decrypt any file with AES in Galois/Counter Mode, as specified in <a href="https://csrc.nist.gov/publications/detail/sp/800-38d/final">NIST SP800-38D</a>. Please note, the same password that was used for encryption must be used for decryption. If you forget (lose) the password, the file cannot be recovered!</p>
<div id="operationModeContainer">
<button class="clickbutton" id="selectEncrypt" type="button" onclick="showEncrypt();">Encrypt a File</button>
<button class="clickbutton" id="selectDncrypt" type="button" onclick="showDecrypt();">Decrypt a File</button>
</div>

<div id="cypherContainer" class="hidden">
<table>
<tr><td>Select File</td><td><input id="selectFile" type="file" aria-label="Select a file"></td><td id="selectFileHint">Select the File you'd like to process.</td></tr>
<tr><td>Password</td><td><input id="mainPassword" type="password" aria-label="Enter password"></td><td id="mainPasswordHint">Strong password, minumum length 8 is characters.</td></tr>
<tr id="trConfirmPassword"><td>Retype Password</td><td><input id="confirmPassword" type="password" aria-label="Confirm password"></td><td id="confirmPasswordHint">Retype your password from above to ensure you didn't mistype it.</td></tr>
</table>
<button id="btnEncrypt" class="clickbutton green" type="button" onclick="encryptFile();">Encrypt</button>
<button id="btnDecrypt" class="clickbutton green" type="button" onclick="decryptFile();">Decrypt</button>
<button id="btnReload" class="clickbutton orange" type="button" onclick="javascript:location.reload();">Reload Page</button>
</div>

<div id="logContainer" class="hidden">
<h2>Log</h2>
<p>This log contains automatically maintained information logs while executing your actions. The entries may help you to identify the cause of any errors.</p>
<pre id="log">Some log data</pre>
</div>

<h2>Privacy</h2>
<p>This is a so called self contained web page. You can run this web page offline on your system. This web page does not require any network connection. Your files and keys do not leave the web browser during the process of encryption or decryption. You can verify this by viewing the source code of this page. You can also check the network traffic while encrypting/decrypting a dummy file.</p>

<h2>Cryptography</h2>
<p>All used cryptography is implemented using the Web Browser's built in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API">Web Crypto API</a>. Files are encrypted using <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt">AES-GCM</a> 256-bit symmetric encryption. The encryption key is derived from a provided password and a random salt using the PBKDF2 derivation method with 1,000,000 iterations along with SHA256 hashing.</p>
<p>The security depends essentially on the strength of the used password. Although the encryption uses AES-GCM with a 256-bit key, the entropy need not be 256-bit. The stronger the password, the stronger the key. If we use an alphabet with the characters [a-z][A-Z][0-9][!"§$%&/()=], we have 72 different characters to choose from. Therefore, we need at least a password consisting of 42 randomly choosen characters out of this alphabet to generate a key with 256-bit entropy. The less strong and complex your password is, the less secure your encryption will be.</p>

<h2>Security</h2>
<p>You shall always check the integrity of this web page. The expected hash of the html file containing this page is posted at <a href="https://github.com/hazelfazel/web-browser-based-file-aes-gcm-encryption-decryption">https://github.com/hazelfazel/web-browser-based-file-aes-gcm-encryption-decryption</a>. Download the plain html file and calculate the SHA256 hash. Verify that the hash of the downloaded html file matches the expected hash from the project's github site.</p>

<h2>License</h2>
<p>This project is licensed under the GPL-3.0 open source license.</p>

<h2>GitHub</h2>
<p>This project can be found on GitHub at <a href="https://github.com/hazelfazel/Web-Browser-Based-AES-GCM-File-Encryption-Decryption">https://github.com/hazelfazel/Web-Browser-Based-AES-GCM-File-Encryption-Decryption.</a></p>

<h2>Contact</h2>
<p>Please contact me for any questions or comments at hazelfazel (at) bitnuts.de</p>

</div>

<script>

function readfile(file) {
	return new Promise((resolve, reject) => {
		let f = new FileReader();  
		f.onload = () => {
			resolve(f.result)
		};
		f.readAsArrayBuffer(file);
	});
}

function ab2str(buf) {
	return String.fromCharCode.apply(null, new Uint8Array(buf));
}

function arr2Hex(buf) {
	let bufArray = Array.from(new Uint8Array(buf));
	return bufArray.map((b) => b.toString(16).padStart(2, '0')).join('');
}

function foldHash(bufA, bufB) {
	let hash1 = Array.from(new Uint8Array(bufA));
	let hash2 = Array.from(new Uint8Array(bufB));
	if ( (hash1.length === hash2.length) && (hash1.length % 8 === 0) ) {
		for (let i=0; i<hash1.length; i++) {
			hash1[i] = hash1[i]^hash2[i];
		}
		while (hash1.length > 6) {
			for (let i=0; i<(hash1.length / 2); i++) {
				hash1[i] = hash1[i]^hash1[(hash1.length / 2)+i];
			}
			hash1 = hash1.slice(0, (hash1.length / 2));
		}
		return hash1;
	}
}

async function deriveKeyIv(password, salt, iterations = 1000000) {
	let encodedPassword = new TextEncoder("utf-8").encode(password);
	let pbkdf2Key = await window.crypto.subtle.importKey(
		"raw",
		encodedPassword,
		{name: "PBKDF2"},
		false,
		["deriveBits", "deriveKey"],
	  );

	let pbkdf2bytes = await window.crypto.subtle.deriveBits(
		{"name": "PBKDF2",
		"salt": salt,
		"iterations": iterations,
		"hash": "SHA-256"
		},
		pbkdf2Key,
		384 // first 32 bytes = 256 bit AES-GCM key, second 16 bytes = 128 bit IV
	);

	let key = await window.crypto.subtle.importKey(
		"raw", pbkdf2bytes.slice(0, 32),
		{name: "AES-GCM",
		length: 256},
		false,
		["encrypt", "decrypt"]
		);
	let iv = pbkdf2bytes.slice(32);
	
	return {"key": key, "iv": iv};
}

async function encrypt(data, key, iv = null) {
	if (iv === null) {
		iv = crypto.getRandomValues(new Uint8Array(16));
	}
	// tagLength can be 32, 64, 96, 104, 112, 120 or 128 (default)
	let cipher = await crypto.subtle.encrypt({"name":"AES-GCM", "iv":iv, tagLength: 128}, key, data);
	return {"cipher": cipher, "iv": iv};
}

async function decrypt(data, iv, key) {
	// tagLength can be 32, 64, 96, 104, 112, 120 or 128 (default)
	return await crypto.subtle.decrypt({"name":"AES-GCM", "iv":iv, tagLength: 128}, key, data);
}

async function encryptFile() {
	selectFileHint.classList.remove("greenspan");
	selectFileHint.classList.remove("redspan");		

	if (selectFile.files.length > 0) {
		selectFileHint.classList.add("greenspan");
		confirmPasswordHint.classList.remove("greenspan");
		confirmPasswordHint.classList.remove("redspan");
		if ( ( mainPassword.value === confirmPassword.value) && ( mainPassword.value !== "" ) && ( mainPassword.value.length >= 8 ) ) {
			confirmPasswordHint.classList.add("greenspan");
			logContainer.classList.remove("hidden");
			try {
				let pbkdf2salt = window.crypto.getRandomValues(new Uint8Array(16));
				let filename = selectFile.files[0].name;
				console.log ( "reading: " + filename );
				log.textContent += "\r\nreading: " + filename;
				let file = await readfile(selectFile.files[0]);
				let hashPlaintext = await crypto.subtle.digest('SHA-256', file);
				log.textContent += "\r\nsha-256 hash of plaintext file: " + arr2Hex(hashPlaintext);
				log.textContent += "\r\nderiving key from password and random salt ...";
				let keyIv = await deriveKeyIv(mainPassword.value, pbkdf2salt);
				console.log ( "pbkdf2salt: " + btoa(String.fromCharCode.apply(null, pbkdf2salt)) );
				log.textContent += "\r\npbkdf2salt: " + btoa(String.fromCharCode.apply(null, pbkdf2salt));
				log.textContent += "\r\nstarting to encrypt ...";
				let someEncryptedData = await encrypt(file, keyIv.key, keyIv.iv);
				log.textContent += "\r\nencryption done, now preparing to save the file ...";
				let concat = await new Blob([ pbkdf2salt, someEncryptedData.cipher ]).arrayBuffer();
				file = new Blob([concat], {type: "application/download"});
				let hashCiphertext = await crypto.subtle.digest('SHA-256', concat);
				log.textContent += "\r\nsha-256 hash of encrypted file: " + arr2Hex(hashCiphertext);
				let hashMagic = foldHash(hashPlaintext, hashCiphertext);
				log.textContent += "\r\nfolded hash magic: " + arr2Hex(hashMagic);
				let blobUrl = URL.createObjectURL(file);
				let element = document.createElement("a");
				element.href = blobUrl;
				element.download = filename + ".enc";
				element.click();
				log.textContent += "\r\n✅ FINISHED.";
			} catch (error) {
				console.error(error);
				log.textContent += "\r\n⛔ EXCEPTION\r\n" + error;
			}
		} else {
			confirmPasswordHint.classList.add("redspan");
		}
	} else {
		selectFileHint.classList.add("redspan");
	}
}

async function decryptFile() {
	selectFileHint.classList.remove("greenspan");
	selectFileHint.classList.remove("redspan");

	if (selectFile.files.length > 0) {
		selectFileHint.classList.add("greenspan");
		mainPasswordHint.classList.remove("greenspan");
		mainPasswordHint.classList.remove("redspan");
		if ( ( mainPassword.value !== "") && ( mainPassword.value.length >= 8 ) ) {
			mainPasswordHint.classList.add("greenspan");
			logContainer.classList.remove("hidden");
			try {
				let pbkdf2salt = window.crypto.getRandomValues(new Uint8Array(16));
				let filename = selectFile.files[0].name;
				console.log ( "loading: " + filename );
				log.textContent += "\r\nreading: " + filename;
				let file = new Uint8Array(await readfile(selectFile.files[0]));
				let hashCiphertext = await crypto.subtle.digest('SHA-256', file);
				log.textContent += "\r\nsha-256 hash of encrypted file: " + arr2Hex(hashCiphertext);
				log.textContent += "\r\nderiving key from password and salt provided in encrypted file ...";
				pbkdf2salt = new Uint8Array(file.slice(0, 16));
				let cipher = file.slice(16);
				let keyIv = await deriveKeyIv(mainPassword.value, pbkdf2salt);
				console.log ( "pbkdf2salt: " + btoa(String.fromCharCode.apply(null, pbkdf2salt)) );
				log.textContent += "\r\npbkdf2salt: " + btoa(String.fromCharCode.apply(null, pbkdf2salt));
				log.textContent += "\r\nstarting to decrypt ...";
				let someDecryptedData = await decrypt(cipher, keyIv.iv, keyIv.key);
				log.textContent += "\r\ndecryption done, now preparing to save the file ...";
				file = new Blob([someDecryptedData], {type: "application/download"});
				let hashPlaintext = await crypto.subtle.digest('SHA-256', someDecryptedData);
				log.textContent += "\r\nsha-256 hash of decrypted file: " + arr2Hex(hashPlaintext);
				let hashMagic = foldHash(hashPlaintext, hashCiphertext);
				log.textContent += "\r\nfolded hash magic: " + arr2Hex(hashMagic);
				let blobUrl = URL.createObjectURL(file);
				let element = document.createElement("a");
				element.href = blobUrl;
				element.download = filename.substring(0, filename.lastIndexOf(".")) || filename;
				element.click();
				log.textContent += "\r\n✅ FINISHED.";
			} catch (error) {
				console.error(error);
				log.textContent += "\r\n⛔ EXCEPTION\r\n" + error;
			}
		} else {
			mainPasswordHint.classList.add("redspan");
		}
	} else {
		selectFileHint.classList.add("redspan");
	}
}

function showEncrypt() {
	operationModeContainer.classList.add("hidden");
	btnDecrypt.classList.add("hidden");
	cypherContainer.classList.remove("hidden");
}

function showDecrypt() {
	operationModeContainer.classList.add("hidden");
	trConfirmPassword.classList.add("hidden");
	btnEncrypt.classList.add("hidden");
	cypherContainer.classList.remove("hidden");
}

</script>

</body>
</html>
